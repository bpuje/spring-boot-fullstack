package com.amigoscode.customer;import com.amigoscode.AbstractTestContainers;import com.amigoscode.entity.Customer;import com.amigoscode.entity.Gender;import com.amigoscode.mapper.CustomerRowMapper;import com.amigoscode.service.CustomerJDBCDataAccessService;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import java.util.List;import java.util.Optional;import java.util.UUID;import static org.assertj.core.api.Assertions.assertThat;class CustomerJDBCDataAccessServiceTest extends AbstractTestContainers {    private CustomerJDBCDataAccessService underTest;    private final CustomerRowMapper customerRowMapper = new CustomerRowMapper();    @BeforeEach    void setUp() {        underTest = new CustomerJDBCDataAccessService(                getJdbcTemplate(),                customerRowMapper);    }    @Test    void selectAllCustomers() {        // Given        String email = FAKER.internet().safeEmailAddress() + "-" + UUID.randomUUID();        String name = FAKER.name().fullName();        Customer customer = new Customer(                name,                email,                "password", 20,                Gender.MALE);        underTest.insertCustomer(customer);        // When        List<Customer> actual = underTest.selectAllCustomers();        // Then        assertThat(actual).isNotEmpty();    }    @Test    void selectCustomerById() {        // Given        String email = FAKER.internet().safeEmailAddress() + "-" + UUID.randomUUID();        Customer customer = new Customer(                FAKER.name().fullName(),                email,                "password", 20,                Gender.MALE);        underTest.insertCustomer(customer);        int id = underTest.selectAllCustomers()                .stream()                .filter(c -> c.getEmail().equals(email))                .map(Customer::getId)                .findFirst()                .orElseThrow();        // When        Optional<Customer> actual = underTest.selectCustomerById(id);        // Then        assertThat(actual).isPresent().hasValueSatisfying(c -> {            assertThat(c.getId()).isEqualTo(id);            assertThat(c.getName()).isEqualTo(customer.getName());            assertThat(c.getEmail()).isEqualTo(customer.getEmail());            assertThat(c.getAge()).isEqualTo(customer.getAge());        });    }    @Test    void willReturnEmptyWhenSelectCustomerById() {        // GIVEN        int id = 0;        // WHEN        var actual = underTest.selectCustomerById(id);        // THEN        assertThat(actual).isEmpty();    }    @Test    void insertCustomer() {        // Given        Customer customer = new Customer(                FAKER.name().fullName(),                FAKER.internet().safeEmailAddress() + "-" + UUID.randomUUID(),                "password", 20,                Gender.MALE);        underTest.insertCustomer(customer);        // When        List<Customer> actual = underTest.selectAllCustomers();        // Then        assertThat(actual).isNotEmpty();    }    @Test    void existsPersonWithEmail() {        // Given        String email = FAKER.internet().safeEmailAddress() + "-" + UUID.randomUUID();        String name = FAKER.name().fullName();        Customer customer = new Customer(                name,                email,                "password", 20,                Gender.MALE);        underTest.insertCustomer(customer);        // When        boolean actual = underTest.existsPersonWithEmail(email);        // Then        assertThat(actual).isTrue();    }    @Test    void existPersonWithEmailReturnsFalseWhenDoesNotExists() {        // GIVEN        String email = FAKER.internet().safeEmailAddress() + "-" + UUID.randomUUID();        // WHEN        boolean actual = underTest.existsPersonWithEmail(email);        // THEN        assertThat(actual).isFalse();    }    @Test    void existsPersonWithId() {        // Given        String email = FAKER.internet().safeEmailAddress() + "-" + UUID.randomUUID();        String name = FAKER.name().fullName();        Customer customer = new Customer(                name,                email,                "password", 20,                Gender.MALE);        underTest.insertCustomer(customer);        int id = underTest.selectAllCustomers()                .stream()                .filter(c -> c.getEmail().equals(email))                .map(Customer::getId)                .findFirst()                .orElseThrow();        // When        boolean actual = underTest.existsPersonWithId(id);        // Then        assertThat(actual).isTrue();    }    @Test    void existsPersonWithIdWillReturnFalseWhenIdNotPresent() {        // GIVEN        int id = -1;        // WHEN        boolean actual = underTest.existsPersonWithId(id);        // THEN        assertThat(actual).isFalse();    }    @Test    void deleteCustomerById() {        // Given        String email = FAKER.internet().safeEmailAddress() + "-" + UUID.randomUUID();        String name = FAKER.name().fullName();        Customer customer = new Customer(                name,                email,                "password", 20,                Gender.MALE);        underTest.insertCustomer(customer);        int id = underTest.selectAllCustomers()                .stream()                .filter(c -> c.getEmail().equals(email))                .map(Customer::getId)                .findFirst()                .orElseThrow();        // When        underTest.deleteCustomerById(id);        // Then        Optional<Customer> actual = underTest.selectCustomerById(id);        assertThat(actual).isNotPresent();    }    @Test    void updateCustomer() {        // Given        String email = FAKER.internet().safeEmailAddress() + "-" + UUID.randomUUID();        String name = FAKER.name().fullName();        Customer customer = new Customer(                name,                email,                "password", 20,                Gender.MALE);        underTest.insertCustomer(customer);        int id = underTest.selectAllCustomers()                .stream()                .filter(c -> c.getEmail().equals(email))                .map(Customer::getId)                .findFirst()                .orElseThrow();        var newName = FAKER.name().fullName();        // when age is name        Customer update = new Customer();        update.setId(id);        update.setName(newName);        underTest.updateCustomer(update);        // Then        Optional<Customer> actual = underTest.selectCustomerById(id);        assertThat(actual).isPresent().hasValueSatisfying(c -> {            assertThat(c.getId()).isEqualTo(id);            assertThat(c.getName()).isEqualTo(newName); // changed            assertThat(c.getEmail()).isEqualTo(customer.getEmail());            assertThat(c.getAge()).isEqualTo(customer.getAge());        });    }    @Test    void updateCustomerAge() {        // GIVEN        String email = FAKER.internet().safeEmailAddress() + "-" + UUID.randomUUID();        String name = FAKER.name().fullName();        Customer customer = new Customer(                name,                email,                "password", 20,                Gender.MALE);        underTest.insertCustomer(customer);        int id = underTest.selectAllCustomers()                .stream()                .filter(c -> c.getEmail().equals(email))                .map(Customer::getId)                .findFirst()                .orElseThrow();        var newAge = 30;        // WHEN age is changed        Customer update = new Customer();        update.setId(id);        update.setAge(newAge);        underTest.updateCustomer(update);        // THEN        Optional<Customer> actual = underTest.selectCustomerById(id);        assertThat(actual).isPresent().hasValueSatisfying(c -> {            assertThat(c.getId()).isEqualTo(id);            assertThat(c.getName()).isEqualTo(customer.getName());            assertThat(c.getEmail()).isEqualTo(customer.getEmail());            assertThat(c.getAge()).isEqualTo(newAge); // changed        });    }    @Test    void willUpdateAllPropertiesCustomer() {        // GIVEN        String email = FAKER.internet().safeEmailAddress() + "-" + UUID.randomUUID();        String name = FAKER.name().fullName();        Customer customer = new Customer(                name,                email,                "password", 20,                Gender.MALE);        underTest.insertCustomer(customer);        int id = underTest.selectAllCustomers()                .stream()                .filter(c -> c.getEmail().equals(email))                .map(Customer::getId)                .findFirst()                .orElseThrow();        // WHEN update with new name, age and email        Customer update = new Customer();        update.setId(id);        update.setName(FAKER.name().fullName());        update.setEmail(FAKER.internet().safeEmailAddress() + "-" + UUID.randomUUID());        update.setAge(FAKER.number().numberBetween(1, 100));        underTest.updateCustomer(update);        // THEN        Optional<Customer> actual = underTest.selectCustomerById(id);        assertThat(actual).isPresent().hasValueSatisfying(c -> {            assertThat(c.getId()).isEqualTo(id);            assertThat(c.getName()).isEqualTo(update.getName()); // changed            assertThat(c.getEmail()).isEqualTo(update.getEmail()); // changed            assertThat(c.getAge()).isEqualTo(update.getAge()); // changed            assertThat(c.getGender()).isEqualTo(Gender.MALE); // not changed        });    }}